# python heft.py -i test.dot

import operator
from Processor import Processor
from read_dag import read_dag
from Task import Task
import matplotlib.pyplot as plt


class HEFT:
    def __init__(self, input_list=None, file=None, verbose=False, p=3, b=0.5, ccr=0.5):
        """ 
        @param file: 输入文件, 由 DAGGEN 生成
        @param verbose: boolean, 输出调试信息
        @param p: processor, 处理器个数
        @param b: 
        @param ccr: 
        """
        if input_list is None and file is not None:
            self.num_tasks, self.num_processors, comp_cost, self.graph = read_dag(
                file, p, b, ccr)
        elif len(input_list) == 4 and file is None:
            self.num_tasks, self.num_processors, comp_cost, self.graph = input_list
        else:
            print('Enter filename or input params')
            raise Exception()

        if verbose:
            print("No. of Tasks: ", self.num_tasks)
            print("No. of processors: ", self.num_processors)
            # print("Computational Cost Matrix:")
            # for i in range(self.num_tasks):
            #     print(comp_cost[i])
            # print("Graph Matrix:")
            # for line in self.graph:
            #     print(line)

        self.tasks = [Task(i) for i in range(self.num_tasks)]
        self.processors = [Processor(i) for i in range(self.num_processors)]

        # HEFT: compute cost and rank
        for i in range(self.num_tasks):
            self.tasks[i].comp_cost = comp_cost[i]
            self.tasks[i].avg_comp = sum(comp_cost[i]) / self.num_processors

        self.__computeRanks(self.tasks[0])

        # if verbose:
        # for task in self.tasks:
        # print("Task ", task.id, "-> Rank: ", task.rank)
        self.tasks.sort(key=lambda x: x.rank, reverse=True)

        self.__allotProcessor()
        self.makespan = max([t.duration['end'] for t in self.tasks])
        self.utility = 10000

    def __computeRanks(self, task):
        # Assume that task[0] is the initial task, as generated by TGFF
        # Assume communicate rate is equal between processors
        curr_rank = 0
        for succ in self.tasks:
            if self.graph[task.id][succ.id] != -1:
                if succ.rank is None:
                    self.__computeRanks(succ)
                curr_rank = max(
                    curr_rank, self.graph[task.id][succ.id] + succ.rank)
        task.rank = task.avg_comp + curr_rank

    def __get_est(self, t, p):
        est = 0
        for pre in self.tasks:
            # if pre also done on p, no communication cost
            if self.graph[pre.id][t.id] != -1:
                c = self.graph[pre.id][t.id] if pre.processor_id != p.id else 0
                est = max(est, pre.duration['end'] + c)
        free_times = []
        if len(p.task_list) == 0:       # no task has yet been assigned to processor
            free_times.append([0, float('inf')])
        else:
            for i in range(len(p.task_list)):
                if i == 0:
                    # if p is not busy from time 0
                    if p.task_list[i].duration['start'] != 0:
                        free_times.append(
                            [0, p.task_list[i].duration['start']])
                else:
                    free_times.append(
                        [p.task_list[i-1].duration['end'], p.task_list[i].duration['start']])
            free_times.append([p.task_list[-1].duration['end'], float('inf')])
        for slot in free_times:     # free_times is already sorted based on avaialbe start times
            if est < slot[0] and slot[0] + t.comp_cost[p.id] <= slot[1]:
                return slot[0]
            if est >= slot[0] and est + t.comp_cost[p.id] <= slot[1]:
                return est

    def __allotProcessor(self):
        for t in self.tasks:
            if t == self.tasks[0]:   # the one with highest rank
                p, w = min(enumerate(t.comp_cost), key=operator.itemgetter(1))
                t.processor_id = p
                t.duration['start'] = 0
                t.duration['end'] = w
                self.processors[p].task_list.append(t)
            else:
                aft = float("inf")
                for p in self.processors:
                    est = self.__get_est(t, p)
                    # print("Task: ", t.id, ", Proc: ", p.id, " -> EST: ", est)
                    eft = est + t.comp_cost[p.id]
                    if eft < aft:   # found better case of processor
                        aft = eft
                        best_p = p.id

                t.processor_id = best_p
                t.duration['start'] = aft - t.comp_cost[best_p]
                t.duration['end'] = aft
                self.processors[best_p].task_list.append(t)
                self.processors[best_p].task_list.sort(
                    key=lambda x: x.duration['start'])

    def __str__(self):
        print_str = ""
        utility = 10000
        for p in self.processors:
            print_str += 'Processor {}:\n '.format(p.id)
            for t in p.task_list:
                print_str += 'Task {}: start = {}, end = {}\n'.format(
                    t.id, t.duration['start'], t.duration['end'])
                utility -= t.duration['end']
        print_str += "Makespan = {}\n".format(self.makespan)
        print_str += "Utility = {}\n".format(utility)
        return print_str

    def getMakespan(self):
        return self.makespan

    def getUtility(self):
        for p in self.processors:
            for t in p.task_list:
                self.utility -= t.duration['end']
        return self.utility


def solution():
    # ./daggen -n 25 --fat 0.4 --density 0.4 --regular 0.2 --jump 2 --minalpha 20 --maxalpha 200 --dot -o ../task25.dot
    files = ['task20.dot', 'task21.dot', 'task22.dot', 'task23.dot', 'task24.dot', 'task25.dot',
             'task26.dot', 'task27.dot', 'task28.dot', 'task29.dot', 'task30.dot', 'task40.dot']
    makespan_dots = []
    utility_dots = []
    for filename in files:
        new_sch = HEFT(file=filename, verbose=False, p=4, b=0.1, ccr=0.1)
        makespan = new_sch.getMakespan()
        utility = new_sch.getUtility()
        makespan_dots.append(makespan)
        utility_dots.append(utility)
        print('Makespan: {}'.format(makespan))
        print('Utility: {}'.format(utility))
        print()
        #
        # print('Num of tasks = {}'.format(num_tasks))
        # print('Utility = {}'.format(final_utility))
        # print('Makespan = {}'.format(final_makespan))
        # utility_dots.append(final_utility)
        # makespan_dots.append(final_makespan)

    x = [20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 40]  # 点的横坐标

    plt.plot(x, makespan_dots, '--', color='r', label="makespan")  # s-:方形
    plt.plot(x, utility_dots, '--', color='g', label="utility")   # o-:圆形
    plt.xlabel("num of tasks")  # 横坐标名字
    plt.ylabel("makespan & utility")  # 纵坐标名字
    plt.legend(loc="best")  # 图例
    plt.show()


if __name__ == "__main__":
    solution()
    # from argparse import ArgumentParser
    # ap = ArgumentParser()

    # ap.add_argument('-i', '--input', required=True,
    #                 help="DAG description as a .dot file")
    # args = ap.parse_args()
    # new_sch = HEFT(file=args.input, verbose=True, p=4, b=0.1, ccr=0.1)

    # print(new_sch)
